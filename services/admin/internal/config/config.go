package config

// This file is generated by hatmax. Do not edit.

import (
	"fmt"
	"os"
	"strings"

	"github.com/knadh/koanf/parsers/yaml"
	"github.com/knadh/koanf/providers/env"
	"github.com/knadh/koanf/providers/posflag"
	"github.com/knadh/koanf/providers/rawbytes"
	"github.com/knadh/koanf/v2"
	"github.com/spf13/pflag"
)

type Config struct {
	Log      LogConfig      `koanf:"log"`
	Server   ServerConfig   `koanf:"server"`
	Services ServicesConfig `koanf:"services"`
	Auth     AuthConfig     `koanf:"auth"`
	Debug    DebugConfig    `koanf:"debug"`
}

type ServerConfig struct {
	Port string `koanf:"port"`
}

type ServicesConfig struct {
	AuthnURL  string `koanf:"authn_url"`
	AuthzURL  string `koanf:"authz_url"`
	EstateURL string `koanf:"estate_url"`
}

type AuthConfig struct {
	CacheTTL      string `koanf:"cache_ttl"`
	SessionSecret string `koanf:"session_secret"`
}

type LogConfig struct {
	Level string `koanf:"level"`
}

type DebugConfig struct {
	Routes bool `koanf:"routes"`
}

func New() *Config {
	return &Config{
		Server: ServerConfig{
			Port: ":8081",
		},
		Services: ServicesConfig{
			AuthnURL:  "http://localhost:8082",
			AuthzURL:  "http://localhost:8083",
			EstateURL: "http://localhost:8084",
		},
		Auth: AuthConfig{
			CacheTTL:      "5m",
			SessionSecret: "change-this-in-production",
		},
		Log: LogConfig{
			Level: "info",
		},
		Debug: DebugConfig{
			Routes: true,
		},
	}
}

// LoadConfig loads configuration from a YAML file, overrides with environment variables, and then with flags.
// 'path' is the path to the YAML config file.
// 'envPrefix' is the prefix for environment variables (e.g., "ADMIN_").
// 'args' are the command-line arguments (os.Args).
func LoadConfig(path, envPrefix string, args []string) (*Config, error) {
	k := koanf.New(".")
	cfg := New() // Start with defaults

	// Setup pflag
	fs := pflag.NewFlagSet(args[0], pflag.ExitOnError)
	fs.String("server.port", ":8081", "Server listen address")
	fs.String("services.authn_url", "http://localhost:8082", "Authn service URL")
	fs.String("services.authz_url", "http://localhost:8083", "Authz service URL")
	fs.String("services.estate_url", "http://localhost:8084", "Estate service URL")
	fs.String("auth.cache_ttl", "5m", "Auth cache TTL")
	fs.String("auth.session_secret", "change-this-in-production", "Session secret")
	fs.String("log.level", "info", "log level (debug, info, error)")
	fs.Bool("debug.routes", true, "Expose /debug/routes endpoint")
	fs.Parse(args[1:])

	raw, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("cannot read config file: %w", err)
	}
	expanded := []byte(os.ExpandEnv(string(raw)))

	if err := k.Load(rawbytes.Provider(expanded), yaml.Parser()); err != nil {
		return nil, fmt.Errorf("cannot parse yaml: %w", err)
	}

	if err := k.Load(env.Provider(envPrefix, ".", func(s string) string {
		return strings.Replace(strings.ToLower(
			strings.TrimPrefix(s, envPrefix)), "_", ".", -1)
	}), nil); err != nil {
		return nil, fmt.Errorf("cannot load env vars: %w", err)
	}

	// Load command-line flags with overrides.
	if err := k.Load(posflag.Provider(fs, ".", k), nil); err != nil {
		return nil, fmt.Errorf("cannot load flags: %w", err)
	}

	if err := k.Unmarshal("", cfg); err != nil {
		return nil, fmt.Errorf("cannot unmarshal config: %w", err)
	}

	// Manual environment variable overrides (flattened keys don't play well with nested paths)
	if val := os.Getenv("ADMIN_SERVER_PORT"); val != "" {
		cfg.Server.Port = val
	}
	if val := os.Getenv("ADMIN_SERVICES_AUTHN_URL"); val != "" {
		cfg.Services.AuthnURL = val
	}
	if val := os.Getenv("ADMIN_SERVICES_AUTHZ_URL"); val != "" {
		cfg.Services.AuthzURL = val
	}
	if val := os.Getenv("ADMIN_SERVICES_ESTATE_URL"); val != "" {
		cfg.Services.EstateURL = val
	}
	if val := os.Getenv("ADMIN_AUTH_SESSION_SECRET"); val != "" {
		cfg.Auth.SessionSecret = val
	}
	if val := os.Getenv("ADMIN_AUTH_CACHE_TTL"); val != "" {
		cfg.Auth.CacheTTL = val
	}
	if val := os.Getenv("ADMIN_LOG_LEVEL"); val != "" {
		cfg.Log.Level = val
	}
	if val := os.Getenv("ADMIN_DEBUG_ROUTES"); val != "" {
		cfg.Debug.Routes = parseBoolEnv(val)
	}

	return cfg, nil
}

func parseBoolEnv(val string) bool {
	switch strings.ToLower(strings.TrimSpace(val)) {
	case "1", "true", "yes", "on":
		return true
	}
	return false
}
