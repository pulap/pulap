package config

// This file is generated by hatmax. Do not edit.

import (
	"fmt"
	"os"
	"strings"

	"github.com/knadh/koanf/parsers/yaml"
	"github.com/knadh/koanf/providers/env"
	"github.com/knadh/koanf/providers/posflag"
	"github.com/knadh/koanf/providers/rawbytes"
	"github.com/knadh/koanf/v2"
	"github.com/spf13/pflag"
)

type Config struct {
	Log      LogConfig      `koanf:"log"`
	Server   ServerConfig   `koanf:"server"`
	Services ServicesConfig `koanf:"services"`
	Auth     AuthConfig     `koanf:"auth"`
	Debug    DebugConfig    `koanf:"debug"`
	Geocode  GeocodeConfig  `koanf:"geocode"`
}

type ServerConfig struct {
	Port string `koanf:"port"`
}

type ServicesConfig struct {
	AuthnURL      string `koanf:"authn_url"`
	AuthzURL      string `koanf:"authz_url"`
	EstateURL     string `koanf:"estate_url"`
	DictionaryURL string `koanf:"dictionary_url"`
}

type AuthConfig struct {
	CacheTTL      string `koanf:"cache_ttl"`
	SessionSecret string `koanf:"session_secret"`
}

type LogConfig struct {
	Level string `koanf:"level"`
}

type DebugConfig struct {
	Routes bool `koanf:"routes"`
}

type GeocodeConfig struct {
	Provider   string              `koanf:"provider"`
	Google     GoogleGeocodeConfig `koanf:"google"`
	OSM        OSMGeocodeConfig    `koanf:"osm"`
	LocationIQ LocationIQConfig    `koanf:"locationiq"`
}

type GoogleGeocodeConfig struct {
	APIKey   string `koanf:"api_key"`
	Endpoint string `koanf:"endpoint"`
}

type OSMGeocodeConfig struct {
	Endpoint string `koanf:"endpoint"`
	Email    string `koanf:"email"`
}

type LocationIQConfig struct {
	Key      string `koanf:"key"`
	Endpoint string `koanf:"endpoint"`
}

func New() *Config {
	return &Config{
		Server: ServerConfig{
			Port: ":8081",
		},
		Services: ServicesConfig{
			AuthnURL:      "http://localhost:8082",
			AuthzURL:      "http://localhost:8083",
			EstateURL:     "http://localhost:8084",
			DictionaryURL: "http://localhost:8085",
		},
		Auth: AuthConfig{
			CacheTTL:      "5m",
			SessionSecret: "change-this-in-production",
		},
		Log: LogConfig{
			Level: "info",
		},
		Debug: DebugConfig{
			Routes: true,
		},
		Geocode: GeocodeConfig{
			Provider: "locationiq",
			Google: GoogleGeocodeConfig{
				Endpoint: "https://maps.googleapis.com/maps/api",
			},
			OSM: OSMGeocodeConfig{
				Endpoint: "https://nominatim.openstreetmap.org",
			},
			LocationIQ: LocationIQConfig{
				Endpoint: "https://api.locationiq.com/v1",
			},
		},
	}
}

// LoadConfig loads configuration from a YAML file, overrides with environment variables, and then with flags.
// 'path' is the path to the YAML config file.
// 'envPrefix' is the prefix for environment variables (e.g., "ADMIN_").
// 'args' are the command-line arguments (os.Args).
func LoadConfig(path, envPrefix string, args []string) (*Config, error) {
	k := koanf.New(".")
	cfg := New() // Start with defaults

	// Setup pflag
	fs := pflag.NewFlagSet(args[0], pflag.ExitOnError)
	fs.String("server.port", ":8081", "Server listen address")
	fs.String("services.authn_url", "http://localhost:8082", "Authn service URL")
	fs.String("services.authz_url", "http://localhost:8083", "Authz service URL")
	fs.String("services.estate_url", "http://localhost:8084", "Estate service URL")
	fs.String("services.dictionary_url", "http://localhost:8085", "Dictionary service URL")
	fs.String("auth.cache_ttl", "5m", "Auth cache TTL")
	fs.String("auth.session_secret", "change-this-in-production", "Session secret")
	fs.String("log.level", "info", "log level (debug, info, error)")
	fs.Bool("debug.routes", true, "Expose /debug/routes endpoint")
	fs.String("geocode.provider", "locationiq", "Location provider to use (locationiq|google|osm)")
	fs.String("geocode.google.api_key", "", "Google Maps API key")
	fs.String("geocode.google.endpoint", "https://maps.googleapis.com/maps/api", "Google Maps API endpoint")
	fs.String("geocode.osm.endpoint", "https://nominatim.openstreetmap.org", "OpenStreetMap Nominatim endpoint")
	fs.String("geocode.osm.email", "", "Contact email for OpenStreetMap requests")
	fs.String("geocode.locationiq.key", "", "LocationIQ API key")
	fs.String("geocode.locationiq.endpoint", "https://api.locationiq.com/v1", "LocationIQ API endpoint")
	fs.Parse(args[1:])

	raw, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("cannot read config file: %w", err)
	}
	expanded := []byte(os.ExpandEnv(string(raw)))

	if err := k.Load(rawbytes.Provider(expanded), yaml.Parser()); err != nil {
		return nil, fmt.Errorf("cannot parse yaml: %w", err)
	}

	if err := k.Load(env.Provider(envPrefix, ".", func(s string) string {
		return strings.Replace(strings.ToLower(
			strings.TrimPrefix(s, envPrefix)), "_", ".", -1)
	}), nil); err != nil {
		return nil, fmt.Errorf("cannot load env vars: %w", err)
	}

	// Load command-line flags with overrides.
	if err := k.Load(posflag.Provider(fs, ".", k), nil); err != nil {
		return nil, fmt.Errorf("cannot load flags: %w", err)
	}

	if err := k.Unmarshal("", cfg); err != nil {
		return nil, fmt.Errorf("cannot unmarshal config: %w", err)
	}

	// Manual environment variable overrides (flattened keys don't play well with nested paths)
	if val := os.Getenv("ADMIN_SERVER_PORT"); val != "" {
		cfg.Server.Port = val
	}
	if val := os.Getenv("ADMIN_SERVICES_AUTHN_URL"); val != "" {
		cfg.Services.AuthnURL = val
	}
	if val := os.Getenv("ADMIN_SERVICES_AUTHZ_URL"); val != "" {
		cfg.Services.AuthzURL = val
	}
	if val := os.Getenv("ADMIN_SERVICES_ESTATE_URL"); val != "" {
		cfg.Services.EstateURL = val
	}
	if val := os.Getenv("ADMIN_SERVICES_DICTIONARY_URL"); val != "" {
		cfg.Services.DictionaryURL = val
	}
	if val := os.Getenv("ADMIN_AUTH_SESSION_SECRET"); val != "" {
		cfg.Auth.SessionSecret = val
	}
	if val := os.Getenv("ADMIN_AUTH_CACHE_TTL"); val != "" {
		cfg.Auth.CacheTTL = val
	}
	if val := os.Getenv("ADMIN_LOG_LEVEL"); val != "" {
		cfg.Log.Level = val
	}
	if val := os.Getenv("ADMIN_DEBUG_ROUTES"); val != "" {
		cfg.Debug.Routes = parseBoolEnv(val)
	}
	if val := os.Getenv("ADMIN_GEOCODE_PROVIDER"); val != "" {
		cfg.Geocode.Provider = val
	}
	if val := os.Getenv("ADMIN_GEOCODE_GOOGLE_API_KEY"); val != "" {
		cfg.Geocode.Google.APIKey = val
	}
	if val := os.Getenv("ADMIN_GEOCODE_GOOGLE_ENDPOINT"); val != "" {
		cfg.Geocode.Google.Endpoint = val
	}
	if val := os.Getenv("ADMIN_GEOCODE_OSM_ENDPOINT"); val != "" {
		cfg.Geocode.OSM.Endpoint = val
	}
	if val := os.Getenv("ADMIN_GEOCODE_OSM_EMAIL"); val != "" {
		cfg.Geocode.OSM.Email = val
	}
	if val := os.Getenv("ADMIN_GEOCODE_LOCATIONIQ_KEY"); val != "" {
		cfg.Geocode.LocationIQ.Key = val
	}
	if val := os.Getenv("ADMIN_GEOCODE_LOCATIONIQ_ENDPOINT"); val != "" {
		cfg.Geocode.LocationIQ.Endpoint = val
	}

	return cfg, nil
}

func parseBoolEnv(val string) bool {
	switch strings.ToLower(strings.TrimSpace(val)) {
	case "1", "true", "yes", "on":
		return true
	}
	return false
}
