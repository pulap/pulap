# Generated by hatmax. Do not edit.

.PHONY: all build run test test-v test-short coverage coverage-html coverage-func coverage-profile coverage-check coverage-100 clean lint fmt vet tidy tidy-fmt quick-test help check ci

APP_NAME := authz
BUILD_DIR := bin
BIN_NAME := $(APP_NAME)
GO_VERSION := 1.23

# Default target
all: build

help:
	@echo "Available targets:"
	@echo "  build        - Build the $(APP_NAME) service"
	@echo "  run          - Build and run the service"
	@echo "  test         - Run all tests"
	@echo "  test-v       - Run all tests with verbose output"
	@echo "  test-short   - Run tests in short mode"
	@echo "  coverage     - Run tests with coverage report"
	@echo "  coverage-html - Generate HTML coverage report"
	@echo "  coverage-func - Show function-level coverage"
	@echo "  coverage-check - Check coverage meets 80% threshold"
	@echo "  coverage-100 - Check for 100% test coverage"
	@echo "  lint         - Run go vet and linters"
	@echo "  fmt          - Format code"
	@echo "  vet          - Run go vet"
	@echo "  tidy         - Run go mod tidy"
	@echo "  clean        - Clean build artifacts and test cache"
	@echo "  check        - Run all quality checks"
	@echo "  ci           - Run CI pipeline with strict checks"

build: tidy-fmt
	@echo "Building $(BIN_NAME)..."
	@mkdir -p $(BUILD_DIR)
	@go build -o $(BUILD_DIR)/$(BIN_NAME) ./main.go
	@echo "$(BIN_NAME) built successfully."

run: build
	@echo "Running $(BIN_NAME)..."
	@$(BUILD_DIR)/$(BIN_NAME)

runpretty: build
	@echo "Running $(BIN_NAME)..."
	@$(BUILD_DIR)/$(BIN_NAME) 2>&1 | awk '{ \
		if(match($$0, /time=([^ ]+)/, t)) time=t[1]; else time=""; \
		if(match($$0, /level=([^ ]+)/, l)) level=l[1]; else level=""; \
		if(match($$0, /msg="([^"]+)"/, m)) msg=m[1]; else msg=""; \
		if(match($$0, /error="([^"]+)"/, e)) error=e[1]; else error=""; \
		if(level != "") { \
			if(toupper(level) == "INFO") level="INF"; \
			else if(toupper(level) == "ERROR") level="ERR"; \
			else if(toupper(level) == "DEBUG") level="DBG"; \
			else if(toupper(level) == "WARN") level="WRN"; \
			output = "[" level "] - " time " - " msg; \
			if(error != "") output = output " ‚Üí " error; \
			print output; \
		} else print $$0; \
	}'

test:
	@echo "Running tests..."
	@go test ./...

# Run tests with verbose output
test-v:
	@echo "Running tests with verbose output..."
	@go test -v ./...

# Run tests in short mode
test-short:
	@echo "Running tests in short mode..."
	@go test -short ./...

# Run tests with coverage
coverage:
	@echo "Running tests with coverage..."
	@go test -cover ./...

# Generate coverage profile and show percentage
coverage-profile:
	@echo "Generating coverage profile..."
	@go test -coverprofile=coverage.out ./...
	@go tool cover -func=coverage.out | tail -1

# Generate HTML coverage report
coverage-html: coverage-profile
	@echo "Generating HTML coverage report..."
	@go tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# Show function-level coverage
coverage-func: coverage-profile
	@echo "Function-level coverage:"
	@go tool cover -func=coverage.out

# Check coverage percentage and fail if below threshold (80%)
coverage-check: coverage-profile
	@COVERAGE=$$(go tool cover -func=coverage.out | tail -1 | awk '{print $$3}' | sed 's/%//'); \
	echo "Current coverage: $$COVERAGE%"; \
	if [ $$(echo "$$COVERAGE < 80" | bc -l) -eq 1 ]; then \
		echo "‚ùå Coverage $$COVERAGE% is below 80% threshold"; \
		exit 1; \
	else \
		echo "‚úÖ Coverage $$COVERAGE% meets the 80% threshold"; \
	fi

# Check coverage percentage and fail if not 100%
coverage-100: coverage-profile
	@COVERAGE=$$(go tool cover -func=coverage.out | tail -1 | awk '{print $$3}' | sed 's/%//'); \
	echo "Current coverage: $$COVERAGE%"; \
	if [ "$$COVERAGE" != "100.0" ]; then \
		echo "‚ùå Coverage $$COVERAGE% is not 100%"; \
		go tool cover -func=coverage.out | grep -v "100.0%"; \
		exit 1; \
	else \
		echo "üéâ Perfect! 100% test coverage achieved!"; \
	fi

clean:
	@echo "Cleaning up..."
	@rm -f $(BUILD_DIR)/$(BIN_NAME)
	@go clean -testcache
	@rm -f coverage.out coverage.html
	@echo "Cleanup complete."

# Run go vet
vet:
	@echo "Running go vet..."
	@go vet ./...

# Run linter (if golangci-lint is available)
lint:
	@echo "Running linter..."
	@go vet ./...
	@if command -v golangci-lint >/dev/null 2>&1; then \
		echo "Running golangci-lint..."; \
		golangci-lint run; \
	else \
		echo "golangci-lint not found, skipping lint check"; \
		echo "Install with: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest"; \
	fi

tidy:
	@echo "Running go work sync from workspace root..."
	@cd ../../ && go work sync
	@echo "go work sync complete."

fmt:
	@echo "Formatting code..."
	@gofmt -w .
	@if command -v goimports >/dev/null 2>&1; then \
		echo "Running goimports..."; \
		goimports -w .; \
	else \
		echo "goimports not found, skipping import organization"; \
	fi
	@echo "Formatting complete."

tidy-fmt: tidy fmt
	@echo "Tidy and formatting complete."

# Run all quality checks
check: fmt vet test coverage-check lint
	@echo "‚úÖ All quality checks passed!"

# CI pipeline - strict checks including 100% coverage
ci: fmt vet test coverage-100 lint
	@echo "üöÄ CI pipeline passed!"

# Temp handy quick test for this service
quick-test: build
	@echo "Quick testing $(BIN_NAME)..."
	@echo "Cleaning up any existing processes on port 8083..."
	@lsof -ti:8083 | xargs -r kill || true
	@sleep 1
	@timeout 5s bash -c './bin/$(BIN_NAME) & sleep 2 && curl -s http://localhost:8083/authz/roles && echo "\n‚úÖ Quick test successful"' || echo "‚ö†Ô∏è  Quick test completed (timeout expected)"
	@echo "Quick test complete."